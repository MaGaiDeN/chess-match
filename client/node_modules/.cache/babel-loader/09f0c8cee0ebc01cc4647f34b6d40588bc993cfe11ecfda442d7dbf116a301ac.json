{"ast":null,"code":"import { Chess } from 'chess.js';\nconst parsePGN = pgnText => {\n  const puzzles = [];\n  console.log('Contenido PGN recibido:', pgnText.substring(0, 200) + '...');\n  if (!pgnText.trim()) {\n    console.error('El archivo PGN está vacío');\n    return puzzles;\n  }\n  const games = pgnText.split('\\n\\n[Event');\n  console.log(`Encontrados ${games.length} juegos para procesar`);\n  games.forEach((game, index) => {\n    if (index === 0 && !game.startsWith('[Event')) {\n      game = '[Event' + game;\n    }\n    try {\n      const fenMatch = game.match(/\\[FEN \"(.*?)\"\\]/);\n      const solutionMatch = game.match(/\\[Solution \"(.*?)\"\\]/);\n      if (fenMatch && solutionMatch) {\n        const fen = fenMatch[1];\n        const solution = solutionMatch[1].split(' ').map(move => move.endsWith('#') ? move.slice(0, -1) : move);\n\n        // Verificar que la posición FEN es válida\n        const chess = new Chess();\n        if (chess.load(fen)) {\n          puzzles.push({\n            id: index + 1,\n            fen: fen,\n            solution: solution,\n            isMate: true,\n            turnToPlay: 'w'\n          });\n          console.log(`Puzzle ${index + 1} procesado:`, {\n            fen: fen,\n            solution: solution\n          });\n        } else {\n          console.error(`FEN inválido en puzzle ${index + 1}:`, fen);\n        }\n      } else {\n        console.error(`Formato inválido en puzzle ${index + 1}:`, 'FEN:', !!fenMatch, 'Solution:', !!solutionMatch);\n      }\n    } catch (error) {\n      console.error(`Error al procesar puzzle ${index + 1}:`, error);\n    }\n  });\n  return puzzles;\n};\nexport const loadPuzzlesFromPGN = async () => {\n  try {\n    console.log('Cargando puzzles...');\n    const response = await fetch('/data/puzzles/mate-en-dos-processed.pgn');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const pgnText = await response.text();\n    console.log('Archivo PGN cargado, tamaño:', pgnText.length, 'bytes');\n    if (!pgnText.trim()) {\n      throw new Error('El archivo PGN está vacío');\n    }\n    const puzzles = parsePGN(pgnText);\n    console.log(`${puzzles.length} puzzles procesados correctamente`);\n    if (puzzles.length === 0) {\n      throw new Error('No se encontraron puzzles válidos en el archivo');\n    }\n    return puzzles;\n  } catch (error) {\n    console.error('Error loading puzzles:', error);\n    return [];\n  }\n};\nexport const getRandomPuzzle = puzzles => {\n  if (!puzzles || puzzles.length === 0) {\n    console.error('No hay puzzles disponibles para seleccionar');\n    return null;\n  }\n  const randomIndex = Math.floor(Math.random() * puzzles.length);\n  const selectedPuzzle = puzzles[randomIndex];\n  console.log('Puzzle seleccionado:', selectedPuzzle);\n  return selectedPuzzle;\n};","map":{"version":3,"names":["Chess","parsePGN","pgnText","puzzles","console","log","substring","trim","error","games","split","length","forEach","game","index","startsWith","fenMatch","match","solutionMatch","fen","solution","map","move","endsWith","slice","chess","load","push","id","isMate","turnToPlay","loadPuzzlesFromPGN","response","fetch","ok","Error","status","text","getRandomPuzzle","randomIndex","Math","floor","random","selectedPuzzle"],"sources":["C:/Users/magai/Desktop/chess-match/client/src/services/puzzleService.js"],"sourcesContent":["import { Chess } from 'chess.js';\r\n\r\nconst parsePGN = (pgnText) => {\r\n  const puzzles = [];\r\n  console.log('Contenido PGN recibido:', pgnText.substring(0, 200) + '...');\r\n  \r\n  if (!pgnText.trim()) {\r\n    console.error('El archivo PGN está vacío');\r\n    return puzzles;\r\n  }\r\n  \r\n  const games = pgnText.split('\\n\\n[Event');\r\n  console.log(`Encontrados ${games.length} juegos para procesar`);\r\n  \r\n  games.forEach((game, index) => {\r\n    if (index === 0 && !game.startsWith('[Event')) {\r\n      game = '[Event' + game;\r\n    }\r\n    \r\n    try {\r\n      const fenMatch = game.match(/\\[FEN \"(.*?)\"\\]/);\r\n      const solutionMatch = game.match(/\\[Solution \"(.*?)\"\\]/);\r\n      \r\n      if (fenMatch && solutionMatch) {\r\n        const fen = fenMatch[1];\r\n        const solution = solutionMatch[1].split(' ').map(move => \r\n          move.endsWith('#') ? move.slice(0, -1) : move\r\n        );\r\n        \r\n        // Verificar que la posición FEN es válida\r\n        const chess = new Chess();\r\n        if (chess.load(fen)) {\r\n          puzzles.push({\r\n            id: index + 1,\r\n            fen: fen,\r\n            solution: solution,\r\n            isMate: true,\r\n            turnToPlay: 'w'\r\n          });\r\n          console.log(`Puzzle ${index + 1} procesado:`, {\r\n            fen: fen,\r\n            solution: solution\r\n          });\r\n        } else {\r\n          console.error(`FEN inválido en puzzle ${index + 1}:`, fen);\r\n        }\r\n      } else {\r\n        console.error(`Formato inválido en puzzle ${index + 1}:`, \r\n          'FEN:', !!fenMatch, \r\n          'Solution:', !!solutionMatch\r\n        );\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error al procesar puzzle ${index + 1}:`, error);\r\n    }\r\n  });\r\n  \r\n  return puzzles;\r\n};\r\n\r\nexport const loadPuzzlesFromPGN = async () => {\r\n  try {\r\n    console.log('Cargando puzzles...');\r\n    const response = await fetch('/data/puzzles/mate-en-dos-processed.pgn');\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`HTTP error! status: ${response.status}`);\r\n    }\r\n    \r\n    const pgnText = await response.text();\r\n    console.log('Archivo PGN cargado, tamaño:', pgnText.length, 'bytes');\r\n    \r\n    if (!pgnText.trim()) {\r\n      throw new Error('El archivo PGN está vacío');\r\n    }\r\n    \r\n    const puzzles = parsePGN(pgnText);\r\n    console.log(`${puzzles.length} puzzles procesados correctamente`);\r\n    \r\n    if (puzzles.length === 0) {\r\n      throw new Error('No se encontraron puzzles válidos en el archivo');\r\n    }\r\n    \r\n    return puzzles;\r\n  } catch (error) {\r\n    console.error('Error loading puzzles:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\nexport const getRandomPuzzle = (puzzles) => {\r\n  if (!puzzles || puzzles.length === 0) {\r\n    console.error('No hay puzzles disponibles para seleccionar');\r\n    return null;\r\n  }\r\n  const randomIndex = Math.floor(Math.random() * puzzles.length);\r\n  const selectedPuzzle = puzzles[randomIndex];\r\n  console.log('Puzzle seleccionado:', selectedPuzzle);\r\n  return selectedPuzzle;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}